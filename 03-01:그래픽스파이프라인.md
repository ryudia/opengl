# 03-01 : 그래픽스 파이프라인<br>
## GRAPHICS PIPELINE
 > 3차원 이미지를 2차원 래스터 이미지로 표현을 하기위한 단계적인 방법<br>
  ![image](https://github.com/ryudia/opengl/assets/164382376/def7a2bd-c249-4a0c-9376-e4a93f103e83)
+ 프로그램 영역, OpenGL 함수 호출
  - Application
    > 그리고 싶은 정점의 위치 / 색상 등을 입력
    > 프로그램 영역, OpenGL 함수 호출
+ GPU 영역
  - Geometry
    > 정점 단위의 처리. 정점의 위치 결정
  - Rasterization
    > 정점 단위로 구성된 삼각형을 픽셀 단위로 변경
  - Screen(Pixel Processing)
    > 픽셀 단위의 처리. 픽셀 색상의 결정
## Voxel? Polygon?
![image](https://github.com/ryudia/opengl/assets/164382376/d138e847-df8a-46b5-a7ce-e9da318eb77d)
> Voxel ↔ Polygon
+ Voxel
  > Volume과 Pixel의 합성어, 부피를 가진 픽셀.<br>
  > 모양이 동일한 정육면체를 모아 물체를 표현.
  > MRI 등 단층 구조를 표현하기에 적합.
+ Polygon
  > 다각형(면)의 조합.<br>
  > 정점 정보(Vertex)로 다각형을 만들고, 표면에 텍스처를 입힘.
  > 일반적으로 표면의 표현에 치중.
## PROGRAMMABLE SHADER
+ Vertex Shader
  > 각 정점의 공간을 변환(로컬 좌표계(물체 중심) → 월드 좌표계(월드 중심) → 카메라 행렬(가상 카메라) → 프로젝션 행렬(원근감)
+ Pixel Shader
  > 텍스처로부터 색을 읽어오거나, 빛을 적용하는 것, 범프 매핑, 그림자, 반사광, 투명처리 등 복잡한 현상 등을 수행.
  > Pixel 각각이 렌더링되므로, 주변의 픽셀이나, 그리는 도형에 대한 정보를 알 수 없다. 이 때문에 Pixel Shader는 스스로 매우 복잡한 효과를 만들어 낼 수는 없다.
